import logging
import time
import traceback as tb
import json
from celery import shared_task
from .actions import generate_agent_profile_picture

logger = logging.getLogger(__name__)


def _serialize_prev_messages(conversation, before_message_id, limit=50):
    """Load and serialize prev messages for reproducibility."""
    from api.messaging.models import Message

    qs = Message.objects.filter(
        conversation=conversation,
        id__lt=before_message_id,
    ).order_by("-id")[:limit]
    return [
        {
            "id": m.id,
            "type": m.type,
            "text": m.text,
            "versions": m.versions,
            "attachments": m.attachments or [],
        }
        for m in reversed(list(qs))
    ]


@shared_task
def async_generate_agent_profile_picture(agent_id: int):
    result = generate_agent_profile_picture(agent_id)
    return result


def _build_user_message_text(user_inputs: list[dict]) -> str:
    """
    Build a plain-text user message from user_inputs.
    Only includes input_text; images and documents are referenced via attachments/tool.
    """
    parts = []
    for inp in user_inputs:
        if inp.get("type") == "input_text":
            text = inp.get("text", "").strip()
            if text:
                parts.append(text)
    return "\n".join(parts) if parts else ""


def _format_attachments_for_model_context(attachments: list[dict]) -> str:
    """
    Render attachment metadata as plain text for model context.

    This is used when building the AgentLoop inputs so the model can discover
    attachment IDs from previous turns, without mutating stored Message.text.
    """
    if not attachments:
        return ""

    lines = ["Attachments available from this message:"]
    for a in attachments:
        a_type = a.get("type") or "attachment"
        aid = a.get("attachment_id") or a.get("id") or ""
        name = a.get("name") or ""
        url = a.get("content") if a_type == "website" else ""

        bits = [a_type]
        if name:
            bits.append(f"name={name}")
        if url:
            bits.append(f"url={url}")
        if aid:
            bits.append(f"attachment_id={aid}")
        lines.append("- " + " | ".join(bits))

    return "\n".join(lines)


def _build_agent_loop_inputs(
    *,
    prev_messages: list[dict],
    current_user_text: str,
    current_user_attachments: list[dict],
    agent_slug: str,
    multiagentic_modality: str,
) -> list[dict]:
    """
    Build the ordered OpenAI input messages for AgentLoop, including previous turns.

    We include attachment metadata inside the message content so the model can
    reference attachment IDs across many turns.
    """
    inputs: list[dict] = []

    for m in prev_messages or []:
        m_type = m.get("type")
        attachments_block = _format_attachments_for_model_context(m.get("attachments") or [])

        if m_type == "user":
            text = m.get("text") or ""
            if attachments_block:
                text = f"{text}\n\n{attachments_block}"
            inputs.append({"role": "user", "content": text})
            continue

        if m_type == "assistant":
            versions = m.get("versions") or []

            if multiagentic_modality == "grupal" and versions:
                # Mirror the streaming behavior: other-agent outputs become user messages.
                for v in versions:
                    v_text = v.get("text") or ""
                    if not v_text:
                        continue
                    if v.get("agent_slug") == agent_slug:
                        text = v_text
                        if attachments_block:
                            text = f"{text}\n\n{attachments_block}"
                        inputs.append({"role": "assistant", "content": text})
                    else:
                        tagged = (
                            "This message was generated by other AI in the conversation called: "
                            f"{v.get('agent_name', 'Unknown')}\n\nAI Response:\n{v_text}"
                        )
                        if attachments_block:
                            tagged = f"{tagged}\n\n{attachments_block}"
                        inputs.append({"role": "user", "content": tagged})
                continue

            # isolated: pick this agent's version if present, else fall back to message text
            picked = None
            for v in versions:
                if v.get("agent_slug") == agent_slug and v.get("text"):
                    picked = v.get("text")
                    break
            text = picked or (m.get("text") or "")
            if attachments_block:
                text = f"{text}\n\n{attachments_block}"
            inputs.append({"role": "assistant", "content": text})
            continue

    # Current user turn (last)
    final_text = current_user_text or ""
    current_block = _format_attachments_for_model_context(current_user_attachments or [])
    if current_block:
        final_text = f"{final_text}\n\n{current_block}"
    inputs.append({"role": "user", "content": final_text})

    return inputs


def _resolve_user_inputs_and_attachments(
    user_inputs: list[dict],
    conversation_id: str | None = None,
):
    """
    Normalize user_inputs to the minimal agent-task contract:
    - input_text
    - input_attachment { attachment_id }

    Also builds Message.attachments JSON for display and returns MessageAttachment
    objects to link to the saved Message.
    """
    from api.messaging.models import MessageAttachment
    from django.conf import settings

    resolved: list[dict] = []
    message_attachments: list[dict] = []
    attachment_objects: list[MessageAttachment] = []

    def _display_url_for_file(att: MessageAttachment) -> str:
        if not att.file:
            return ""
        api_base = getattr(settings, "API_BASE_URL", None) or ""
        url = att.file.url
        if api_base and not url.startswith("http"):
            return f"{api_base.rstrip('/')}{url}"
        return url

    for inp in user_inputs:
        input_type = inp.get("type", "")

        if input_type == "input_text":
            resolved.append({"type": "input_text", "text": inp.get("text", "")})
            continue

        if input_type == "input_attachment":
            attachment_id = inp.get("attachment_id")
            if not attachment_id:
                raise ValueError("input_attachment requires attachment_id")
            try:
                if conversation_id:
                    att = MessageAttachment.objects.get(
                        id=attachment_id,
                        conversation_id=conversation_id,
                    )
                else:
                    att = MessageAttachment.objects.get(id=attachment_id)
            except MessageAttachment.DoesNotExist:
                raise ValueError(
                    f"MessageAttachment {attachment_id} not found"
                    + (f" for conversation {conversation_id}" if conversation_id else "")
                )

            attachment_objects.append(att)
            resolved.append({"type": "input_attachment", "attachment_id": str(att.id)})

            # Attachments shown in Message history (UI)
            kind = getattr(att, "kind", "") or ""
            if kind == "website":
                message_attachments.append(
                    {
                        "type": "website",
                        "content": getattr(att, "url", "") or "",
                        "attachment_id": str(att.id),
                    }
                )
            elif kind == "rag_document":
                rag_doc = getattr(att, "rag_document", None)
                message_attachments.append(
                    {
                        "type": "rag_document",
                        "name": getattr(rag_doc, "name", None) if rag_doc else None,
                        "attachment_id": str(att.id),
                    }
                )
            else:
                # Default: file attachment (image or generic document)
                display_url = _display_url_for_file(att)
                is_image = bool(att.content_type and att.content_type.startswith("image/"))
                filename = (
                    att.file.name.split("/")[-1]
                    if att.file and att.file.name
                    else ("image" if is_image else "document")
                )
                message_attachments.append(
                    {
                        "type": "image" if is_image else "document",
                        "content": display_url,
                        "name": filename,
                        "attachment_id": str(att.id),
                    }
                )
            continue

        raise ValueError(f"Unsupported user input type '{input_type}'")

    return resolved, message_attachments, attachment_objects


def _extract_create_image_attachments(tool_calls: list[dict]) -> tuple[list[dict], list[str]]:
    """
    Extract image attachment descriptors from AgentLoop tool_calls.

    create_image tool returns JSON like:
      { attachment_id, name, content, ... }

    We persist those into Message.attachments (for UI) and keep attachment IDs
    to link MessageAttachment.message after the assistant Message exists.
    """
    if not tool_calls:
        return [], []

    attachments: list[dict] = []
    attachment_ids: list[str] = []

    for call in tool_calls:
        try:
            if (call or {}).get("tool_name") != "create_image":
                continue
            raw = (call or {}).get("result") or ""
            if not isinstance(raw, str) or not raw.strip():
                continue
            data = json.loads(raw)
            if not isinstance(data, dict):
                continue
            aid = data.get("attachment_id")
            content = data.get("content") or ""
            name = data.get("name") or "image"
            if not aid or not content:
                continue
            attachments.append(
                {
                    "type": "image",
                    "content": content,
                    "name": name,
                    "attachment_id": str(aid),
                }
            )
            attachment_ids.append(str(aid))
        except Exception:
            # Never fail the whole agent task because of attachment parsing
            continue

    return attachments, attachment_ids


@shared_task
def conversation_agent_task(
    conversation_id: str,
    user_inputs: list[dict],
    tool_names: list[str],
    agent_slugs: list[str],
    plugin_slugs: list[str] | None = None,
    multiagentic_modality: str = "isolated",
    max_iterations: int = 10,
    user_id: int | None = None,
):
    """
    Celery task that runs an AgentLoop for one or more agents in a conversation.

    Resolves agents from their slugs, derives instructions and model for each,
    executes the agent loop for each (sequentially), and emits real-time status
    updates via Redis pub/sub (notify_user) so the frontend can show progress.

    For multiagentic_modality="grupal", each agent sees previous agents' outputs
    as context. For "isolated", each agent only sees the user message.

    Args:
        conversation_id: UUID of the conversation
        user_inputs: list of input dicts, e.g. [{"type": "input_text", "text": "..."}]
        tool_names: list of tool names to resolve from the registry
        agent_slugs: list of Agent slugs to run (in order)
        multiagentic_modality: "isolated" or "grupal"
        user_id: ID of the user (for notifications)

    Returns:
        dict with status, output, iterations, tool_calls_count, message_id
    """
    from api.ai_layers.agent_loop import AgentLoop
    from api.ai_layers.models import Agent, AgentSession
    from api.ai_layers.plugins import format_plugins_instruction
    from api.ai_layers.tools import resolve_tools
    from api.ai_layers.schemas import (
        AgentSessionInputs,
        AgentSessionOutputs,
        AgentRef,
        ModelRef,
        OutputValue,
        OutputError,
    )
    from api.notify.actions import notify_user
    from api.messaging.models import Conversation, Message

    # Get conversation first (needed for validation in resolve)
    try:
        conversation = Conversation.objects.get(id=conversation_id)
    except Conversation.DoesNotExist:
        logger.error("Conversation %s not found", conversation_id)
        notify_user(
            user_id,
            "agent_events_channel",
            {"type": "error", "conversation_id": conversation_id, "error": f"Conversation {conversation_id} not found"},
        )
        return {"status": "error", "error": "Conversation not found"}

    # Normalize plugin slugs (preserve order, dedupe).
    if plugin_slugs is None:
        plugin_slugs = []
    if not isinstance(plugin_slugs, list):
        plugin_slugs = []
    seen_plugins: set[str] = set()
    normalized_plugins: list[str] = []
    for p in plugin_slugs:
        if not isinstance(p, str):
            continue
        s = p.strip()
        if not s or s in seen_plugins:
            continue
        seen_plugins.add(s)
        normalized_plugins.append(s)
    plugin_slugs = normalized_plugins

    # Normalize inputs and collect attachments for Message (strict contract)
    try:
        resolved_inputs, message_attachments, attachment_objects = _resolve_user_inputs_and_attachments(
            user_inputs, conversation_id=conversation_id
        )
    except ValueError as e:
        notify_user(
            user_id,
            "agent_events_channel",
            {"type": "error", "conversation_id": conversation_id, "error": str(e)},
        )
        return {"status": "error", "error": str(e)}
    user_message_text = _build_user_message_text(resolved_inputs)

    def emit_event(event_type: str, data: dict) -> None:
        payload = {"type": event_type, "conversation_id": conversation_id, **data}
        notify_user(user_id, "agent_events_channel", payload)

    def emit_finished(data: dict) -> None:
        payload = {"conversation_id": conversation_id, **data}
        notify_user(user_id, "agent_loop_finished", payload)

    logger.info(
        "conversation_agent_task started: conversation=%s user=%s agents=%s tools=%s modality=%s",
        conversation_id, user_id, agent_slugs, tool_names, multiagentic_modality,
    )

    agent_sessions_created = []
    try:
        # ---- Save user message ----
        try:
            user_message = Message.objects.create(
                conversation=conversation,
                type="user",
                text=user_message_text,
                attachments=message_attachments,
            )
            for att in attachment_objects:
                att.message = user_message
                att.save(update_fields=["message"])
        except Exception:
            emit_event("error", {"error": "Failed to save user message"})
            return {"status": "error", "error": "Failed to save user message"}

        # ---- Resolve agents in order ----
        agents_by_slug = {a.slug: a for a in Agent.objects.filter(slug__in=agent_slugs)}
        agents_ordered = [agents_by_slug[s] for s in agent_slugs if s in agents_by_slug]
        if not agents_ordered:
            emit_event("error", {"error": "No valid agents found"})
            return {"status": "error", "error": "No valid agents found"}

        versions = []
        total_iterations = 0
        total_tool_calls = 0
        assistant_message_attachments: list[dict] = []
        assistant_attachment_ids: list[str] = []

        prev_messages = _serialize_prev_messages(conversation, user_message.id)

        attachment_ids = [
            inp.get("attachment_id") or inp.get("id")
            for inp in resolved_inputs
            if inp.get("type") == "input_attachment"
        ]
        attachment_ids_instruction = ""
        if attachment_ids:
            attachment_ids_instruction = (
                "\n\nThe user has attached items. Read them with the read_attachment tool. "
                "Available attachment IDs: " + ", ".join(str(aid) for aid in attachment_ids if aid) + "\n"
            )

        for index, agent in enumerate(agents_ordered):
            instructions = agent.format_prompt()
            llm = agent.llm
            model_slug = llm.slug if llm else (agent.model_slug or "gpt-5.2")

            if attachment_ids_instruction:
                instructions = instructions + attachment_ids_instruction

            # If the user enabled RAG/Web Search, they expect the agent to use it.
            if "rag_query" in (tool_names or []):
                instructions += (
                    "\n\nRAG is enabled for this conversation. "
                    "Before answering, you MUST call rag_query at least once with a small list of queries "
                    "(1-5) derived from the user's latest request. "
                    "If rag_query returns no results, say so briefly and continue with best-effort."
                )
            if "explore_web" in (tool_names or []):
                instructions += (
                    "\n\nWeb Search is enabled for this conversation. "
                    "Before answering, you MUST call explore_web at least once with an appropriate query "
                    "derived from the user's latest request. "
                    "Use the results to improve factuality; if it returns no results, say so briefly and continue."
                )
            if "create_image" in (tool_names or []):
                instructions += (
                    "\n\nImage generation is enabled for this conversation. "
                    "If the user asks you to generate an image, you can call create_image(prompt, model, aspect_ratio). "
                    "Use model='gpt-image-1.5'. aspect_ratio must be one of: square, landscape, portrait."
                    "\n\nWhen referencing an attachment inside your message markdown, prefer this format: "
                    "![Alt text](attachment:<attachment_id>). Do NOT invent /media/... URLs."
                )

            # For grupal: prepend previous agents' outputs to instructions
            if multiagentic_modality == "grupal" and versions:
                prev_context = (
                    "\n\nYou must consider that the other AI(s) in the conversation "
                    "are other users and refer to them as such. ONLY GIVE YOUR RESPONSE."
                    "\n\nResponses from other AIs so far:\n"
                )
                for v in versions:
                    prev_context += f"\n--- {v.get('agent_name', 'Unknown')} ---\n{v.get('text', '')}\n"
                instructions = instructions + prev_context

            # Plugins: canonical instruction blocks (server-side allowlist).
            instructions += format_plugins_instruction(plugin_slugs)

            # ---- Create AgentSession (inputs) ----
            model_ref = ModelRef(
                id=llm.id if llm else 0,
                slug=model_slug,
                provider=llm.provider.name if llm else "openai",
            )
            inputs_data = AgentSessionInputs(
                instructions=instructions,
                user_inputs=resolved_inputs,
                user_message_text=user_message_text,
                tool_names=tool_names,
                plugin_slugs=plugin_slugs,
                agent=AgentRef(id=agent.id, slug=agent.slug, name=agent.name),
                model=model_ref,
                multiagentic_modality=multiagentic_modality,
                prev_messages=prev_messages,
                max_iterations=max_iterations,
            ).model_dump()

            session = AgentSession.objects.create(
                conversation=conversation,
                user_message=user_message,
                task_type="chat_message",
                inputs=inputs_data,
                outputs={},
                agent_index=index,
            )
            agent_sessions_created.append(session)
            start_time = time.perf_counter()

            def on_event(event_type: str, data: dict) -> None:
                payload = {
                    "type": event_type,
                    "conversation_id": conversation_id,
                    "agent_slug": agent.slug,
                    "agent_name": agent.name,
                    **data,
                }
                notify_user(user_id, "agent_events_channel", payload)

            # Resolve tools per-agent so tools can use agent_slug closures (e.g. rag_query)
            tools = (
                resolve_tools(
                    tool_names,
                    conversation_id=conversation_id,
                    user_id=user_id,
                    agent_slug=agent.slug,
                )
                if tool_names
                else []
            )

            loop = AgentLoop(
                tools=tools,
                instructions=instructions,
                model=model_slug,
                max_iterations=max_iterations,
                on_event=on_event,
            )

            openai_inputs = _build_agent_loop_inputs(
                prev_messages=prev_messages,
                current_user_text=user_message_text,
                current_user_attachments=message_attachments,
                agent_slug=agent.slug,
                multiagentic_modality=multiagentic_modality,
            )
            result = loop.run(openai_inputs)

            # ---- Update AgentSession (outputs) ----
            from django.utils import timezone

            # ---- Collect any generated image attachments ----
            new_atts, new_ids = _extract_create_image_attachments(result.tool_calls or [])
            if new_atts:
                assistant_message_attachments.extend(new_atts)
            if new_ids:
                assistant_attachment_ids.extend(new_ids)

            if isinstance(result.output, str):
                output_value = OutputValue(type="string", value=result.output)
            elif hasattr(result.output, "model_dump"):
                dump = result.output.model_dump(mode="json")
                output_value = OutputValue(type="json", value=dump)
            else:
                output_value = OutputValue(type="string", value=str(result.output))

            outputs_data = AgentSessionOutputs(
                messages=result.messages,
                output=output_value,
                usage=result.usage,
                status="completed",
                error=None,
            ).model_dump()

            session.outputs = outputs_data
            session.iterations = result.iterations
            session.tool_calls_count = len(result.tool_calls)
            session.ended_at = timezone.now()
            session.total_duration = time.perf_counter() - start_time
            session.save()

            # ---- Extract output text for version ----
            import json as _json
            if isinstance(result.output, str):
                output_text = result.output
            elif hasattr(result.output, "model_dump"):
                output_text = _json.dumps(result.output.model_dump(), default=str)
            else:
                output_text = str(result.output)

            version = {
                "agent_slug": agent.slug,
                "agent_name": agent.name,
                "type": "assistant",
                "usage": {
                    "prompt_tokens": result.usage.get("prompt_tokens", 0),
                    "completion_tokens": result.usage.get("completion_tokens", 0),
                    "total_tokens": result.usage.get("total_tokens", 0),
                    "model_slug": model_slug,
                },
            }
            version["text"] = output_text
            versions.append(version)

            total_iterations += result.iterations
            total_tool_calls += len(result.tool_calls)

            # Emit version immediately so frontend can display it in real time
            emit_event("agent_version_ready", {"version": version})

            emit_event("agent_complete", {
                "agent_slug": agent.slug,
                "agent_name": agent.name,
                "index": index + 1,
                "total": len(agents_ordered),
            })

        # ---- Save assistant message with all versions ----
        assistant_message_id = None
        primary_text = versions[0]["text"] if versions else ""
        try:
            conversation = Conversation.objects.get(id=conversation_id)
            assistant_msg = Message.objects.create(
                conversation=conversation,
                type="assistant",
                text=primary_text,
                versions=versions,
                attachments=assistant_message_attachments,
            )
            assistant_message_id = assistant_msg.id
            # Link generated attachments to this assistant message for list_attachments/read_attachment
            if assistant_attachment_ids:
                from api.messaging.models import MessageAttachment

                MessageAttachment.objects.filter(
                    conversation_id=conversation_id,
                    id__in=assistant_attachment_ids,
                ).update(message=assistant_msg)
            for s in agent_sessions_created:
                s.assistant_message = assistant_msg
                s.save(update_fields=["assistant_message"])
            conversation.generate_title()
        except Conversation.DoesNotExist:
            logger.warning(
                "Conversation %s not found when saving assistant message",
                conversation_id,
            )

        emit_finished({
            "output": primary_text,
            "message_id": assistant_message_id,
            "versions": versions,
            "iterations": total_iterations,
            "tool_calls_count": total_tool_calls,
        })

        logger.info(
            "conversation_agent_task completed: conversation=%s agents=%d iterations=%d tool_calls=%d",
            conversation_id, len(versions), total_iterations, total_tool_calls,
        )

        return {
            "status": "completed",
            "output": primary_text,
            "iterations": total_iterations,
            "tool_calls_count": total_tool_calls,
            "message_id": assistant_message_id,
        }

    except Exception as e:
        logger.error(
            "conversation_agent_task failed: conversation=%s error=%s",
            conversation_id, str(e),
        )
        emit_event("error", {"error": str(e)})

        # Update last created session with error outputs if any
        if agent_sessions_created:
            from django.utils import timezone

            last_session = agent_sessions_created[-1]
            outputs_data = AgentSessionOutputs(
                messages=last_session.outputs.get("messages", []),
                output=OutputValue(type="string", value=""),
                usage=last_session.outputs.get("usage", {}),
                status="error",
                error=OutputError(message=str(e), traceback=tb.format_exc()),
            ).model_dump()
            last_session.outputs = outputs_data
            last_session.ended_at = timezone.now()
            last_session.tool_calls_count = sum(
                1 for m in last_session.outputs.get("messages", [])
                if m.get("type") == "function_call"
            )
            if last_session.started_at:
                last_session.total_duration = (
                    timezone.now() - last_session.started_at
                ).total_seconds()
            last_session.save(
                update_fields=["outputs", "ended_at", "total_duration", "tool_calls_count"]
            )

        return {"status": "error", "error": str(e)}
