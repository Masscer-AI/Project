import logging
import time
import traceback as tb
from celery import shared_task
from .actions import generate_agent_profile_picture

logger = logging.getLogger(__name__)


def _serialize_prev_messages(conversation, before_message_id, limit=50):
    """Load and serialize prev messages for reproducibility."""
    from api.messaging.models import Message

    qs = Message.objects.filter(
        conversation=conversation,
        id__lt=before_message_id,
    ).order_by("-id")[:limit]
    return [
        {
            "id": m.id,
            "type": m.type,
            "text": m.text,
            "versions": m.versions,
            "attachments": m.attachments or [],
        }
        for m in reversed(list(qs))
    ]


@shared_task
def async_generate_agent_profile_picture(agent_id: int):
    result = generate_agent_profile_picture(agent_id)
    return result


def _build_user_message_text(user_inputs: list[dict]) -> str:
    """
    Build a plain-text user message from user_inputs.
    Only includes input_text; images and documents are referenced via attachments/tool.
    """
    parts = []
    for inp in user_inputs:
        if inp.get("type") == "input_text":
            text = inp.get("text", "").strip()
            if text:
                parts.append(text)
    return "\n".join(parts) if parts else ""


def _format_attachments_for_model_context(attachments: list[dict]) -> str:
    """
    Render attachment metadata as plain text for model context.

    This is used when building the AgentLoop inputs so the model can discover
    attachment IDs from previous turns, without mutating stored Message.text.
    """
    if not attachments:
        return ""

    lines = ["Attachments available from this message:"]
    for a in attachments:
        a_type = a.get("type") or "attachment"
        aid = a.get("attachment_id") or a.get("id") or ""
        name = a.get("name") or ""
        url = a.get("content") if a_type == "website" else ""

        bits = [a_type]
        if name:
            bits.append(f"name={name}")
        if url:
            bits.append(f"url={url}")
        if aid:
            bits.append(f"attachment_id={aid}")
        lines.append("- " + " | ".join(bits))

    return "\n".join(lines)


def _build_agent_loop_inputs(
    *,
    prev_messages: list[dict],
    current_user_text: str,
    current_user_attachments: list[dict],
    agent_slug: str,
    multiagentic_modality: str,
) -> list[dict]:
    """
    Build the ordered OpenAI input messages for AgentLoop, including previous turns.

    We include attachment metadata inside the message content so the model can
    reference attachment IDs across many turns.
    """
    inputs: list[dict] = []

    for m in prev_messages or []:
        m_type = m.get("type")
        attachments_block = _format_attachments_for_model_context(m.get("attachments") or [])

        if m_type == "user":
            text = m.get("text") or ""
            if attachments_block:
                text = f"{text}\n\n{attachments_block}"
            inputs.append({"role": "user", "content": text})
            continue

        if m_type == "assistant":
            versions = m.get("versions") or []

            if multiagentic_modality == "grupal" and versions:
                # Mirror the streaming behavior: other-agent outputs become user messages.
                for v in versions:
                    v_text = v.get("text") or ""
                    if not v_text:
                        continue
                    if v.get("agent_slug") == agent_slug:
                        text = v_text
                        if attachments_block:
                            text = f"{text}\n\n{attachments_block}"
                        inputs.append({"role": "assistant", "content": text})
                    else:
                        tagged = (
                            "This message was generated by other AI in the conversation called: "
                            f"{v.get('agent_name', 'Unknown')}\n\nAI Response:\n{v_text}"
                        )
                        if attachments_block:
                            tagged = f"{tagged}\n\n{attachments_block}"
                        inputs.append({"role": "user", "content": tagged})
                continue

            # isolated: pick this agent's version if present, else fall back to message text
            picked = None
            for v in versions:
                if v.get("agent_slug") == agent_slug and v.get("text"):
                    picked = v.get("text")
                    break
            text = picked or (m.get("text") or "")
            if attachments_block:
                text = f"{text}\n\n{attachments_block}"
            inputs.append({"role": "assistant", "content": text})
            continue

    # Current user turn (last)
    final_text = current_user_text or ""
    current_block = _format_attachments_for_model_context(current_user_attachments or [])
    if current_block:
        final_text = f"{final_text}\n\n{current_block}"
    inputs.append({"role": "user", "content": final_text})

    return inputs


def _resolve_user_inputs_and_attachments(
    user_inputs: list[dict],
    conversation_id: str | None = None,
):
    """
    Normalize user_inputs to the minimal agent-task contract:
    - input_text
    - input_attachment { attachment_id }

    Also builds Message.attachments JSON for display and returns MessageAttachment
    objects to link to the saved Message.
    """
    from api.messaging.models import MessageAttachment
    from django.conf import settings

    resolved: list[dict] = []
    message_attachments: list[dict] = []
    attachment_objects: list[MessageAttachment] = []

    def _display_url_for_file(att: MessageAttachment) -> str:
        if not att.file:
            return ""
        api_base = getattr(settings, "API_BASE_URL", None) or ""
        url = att.file.url
        if api_base and not url.startswith("http"):
            return f"{api_base.rstrip('/')}{url}"
        return url

    for inp in user_inputs:
        input_type = inp.get("type", "")

        if input_type == "input_text":
            resolved.append({"type": "input_text", "text": inp.get("text", "")})
            continue

        if input_type == "input_attachment":
            attachment_id = inp.get("attachment_id")
            if not attachment_id:
                raise ValueError("input_attachment requires attachment_id")
            try:
                if conversation_id:
                    att = MessageAttachment.objects.get(
                        id=attachment_id,
                        conversation_id=conversation_id,
                    )
                else:
                    att = MessageAttachment.objects.get(id=attachment_id)
            except MessageAttachment.DoesNotExist:
                raise ValueError(
                    f"MessageAttachment {attachment_id} not found"
                    + (f" for conversation {conversation_id}" if conversation_id else "")
                )

            attachment_objects.append(att)
            resolved.append({"type": "input_attachment", "attachment_id": str(att.id)})

            # Attachments shown in Message history (UI)
            kind = getattr(att, "kind", "") or ""
            if kind == "website":
                message_attachments.append(
                    {
                        "type": "website",
                        "content": getattr(att, "url", "") or "",
                        "attachment_id": str(att.id),
                    }
                )
            elif kind == "rag_document":
                rag_doc = getattr(att, "rag_document", None)
                message_attachments.append(
                    {
                        "type": "rag_document",
                        "name": getattr(rag_doc, "name", None) if rag_doc else None,
                        "attachment_id": str(att.id),
                    }
                )
            else:
                # Default: file attachment (image or generic document)
                display_url = _display_url_for_file(att)
                is_image = bool(att.content_type and att.content_type.startswith("image/"))
                filename = (
                    att.file.name.split("/")[-1]
                    if att.file and att.file.name
                    else ("image" if is_image else "document")
                )
                message_attachments.append(
                    {
                        "type": "image" if is_image else "document",
                        "content": display_url,
                        "name": filename,
                        "attachment_id": str(att.id),
                    }
                )
            continue

        raise ValueError(f"Unsupported user input type '{input_type}'")

    return resolved, message_attachments, attachment_objects


@shared_task
def conversation_agent_task(
    conversation_id: str,
    user_inputs: list[dict],
    tool_names: list[str],
    agent_slugs: list[str],
    multiagentic_modality: str = "isolated",
    max_iterations: int = 10,
    user_id: int | None = None,
):
    """
    Celery task that runs an AgentLoop for one or more agents in a conversation.

    Resolves agents from their slugs, derives instructions and model for each,
    executes the agent loop for each (sequentially), and emits real-time status
    updates via Redis pub/sub (notify_user) so the frontend can show progress.

    For multiagentic_modality="grupal", each agent sees previous agents' outputs
    as context. For "isolated", each agent only sees the user message.

    Args:
        conversation_id: UUID of the conversation
        user_inputs: list of input dicts, e.g. [{"type": "input_text", "text": "..."}]
        tool_names: list of tool names to resolve from the registry
        agent_slugs: list of Agent slugs to run (in order)
        multiagentic_modality: "isolated" or "grupal"
        user_id: ID of the user (for notifications)

    Returns:
        dict with status, output, iterations, tool_calls_count, message_id
    """
    from api.ai_layers.agent_loop import AgentLoop
    from api.ai_layers.models import Agent, AgentSession
    from api.ai_layers.tools import resolve_tools
    from api.ai_layers.schemas import (
        AgentSessionInputs,
        AgentSessionOutputs,
        AgentRef,
        ModelRef,
        OutputValue,
        OutputError,
    )
    from api.notify.actions import notify_user
    from api.messaging.models import Conversation, Message

    # Get conversation first (needed for validation in resolve)
    try:
        conversation = Conversation.objects.get(id=conversation_id)
    except Conversation.DoesNotExist:
        logger.error("Conversation %s not found", conversation_id)
        notify_user(
            user_id,
            "agent_events_channel",
            {"type": "error", "conversation_id": conversation_id, "error": f"Conversation {conversation_id} not found"},
        )
        return {"status": "error", "error": "Conversation not found"}

    # Normalize inputs and collect attachments for Message (strict contract)
    try:
        resolved_inputs, message_attachments, attachment_objects = _resolve_user_inputs_and_attachments(
            user_inputs, conversation_id=conversation_id
        )
    except ValueError as e:
        notify_user(
            user_id,
            "agent_events_channel",
            {"type": "error", "conversation_id": conversation_id, "error": str(e)},
        )
        return {"status": "error", "error": str(e)}
    user_message_text = _build_user_message_text(resolved_inputs)

    def emit_event(event_type: str, data: dict) -> None:
        payload = {"type": event_type, "conversation_id": conversation_id, **data}
        notify_user(user_id, "agent_events_channel", payload)

    def emit_finished(data: dict) -> None:
        payload = {"conversation_id": conversation_id, **data}
        notify_user(user_id, "agent_loop_finished", payload)

    logger.info(
        "conversation_agent_task started: conversation=%s user=%s agents=%s tools=%s modality=%s",
        conversation_id, user_id, agent_slugs, tool_names, multiagentic_modality,
    )

    agent_sessions_created = []
    try:
        # ---- Save user message ----
        try:
            user_message = Message.objects.create(
                conversation=conversation,
                type="user",
                text=user_message_text,
                attachments=message_attachments,
            )
            for att in attachment_objects:
                att.message = user_message
                att.save(update_fields=["message"])
        except Exception:
            emit_event("error", {"error": "Failed to save user message"})
            return {"status": "error", "error": "Failed to save user message"}

        # ---- Resolve agents in order ----
        agents_by_slug = {a.slug: a for a in Agent.objects.filter(slug__in=agent_slugs)}
        agents_ordered = [agents_by_slug[s] for s in agent_slugs if s in agents_by_slug]
        if not agents_ordered:
            emit_event("error", {"error": "No valid agents found"})
            return {"status": "error", "error": "No valid agents found"}

        versions = []
        total_iterations = 0
        total_tool_calls = 0

        prev_messages = _serialize_prev_messages(conversation, user_message.id)

        attachment_ids = [
            inp.get("attachment_id") or inp.get("id")
            for inp in resolved_inputs
            if inp.get("type") == "input_attachment"
        ]
        attachment_ids_instruction = ""
        if attachment_ids:
            attachment_ids_instruction = (
                "\n\nThe user has attached items. Read them with the read_attachment tool. "
                "Available attachment IDs: " + ", ".join(str(aid) for aid in attachment_ids if aid) + "\n"
            )

        for index, agent in enumerate(agents_ordered):
            instructions = agent.format_prompt()
            llm = agent.llm
            model_slug = llm.slug if llm else (agent.model_slug or "gpt-5.2")

            if attachment_ids_instruction:
                instructions = instructions + attachment_ids_instruction

            # For grupal: prepend previous agents' outputs to instructions
            if multiagentic_modality == "grupal" and versions:
                prev_context = (
                    "\n\nYou must consider that the other AI(s) in the conversation "
                    "are other users and refer to them as such. ONLY GIVE YOUR RESPONSE."
                    "\n\nResponses from other AIs so far:\n"
                )
                for v in versions:
                    prev_context += f"\n--- {v.get('agent_name', 'Unknown')} ---\n{v.get('text', '')}\n"
                instructions = instructions + prev_context

            # ---- Create AgentSession (inputs) ----
            model_ref = ModelRef(
                id=llm.id if llm else 0,
                slug=model_slug,
                provider=llm.provider.name if llm else "openai",
            )
            inputs_data = AgentSessionInputs(
                instructions=instructions,
                user_inputs=resolved_inputs,
                user_message_text=user_message_text,
                tool_names=tool_names,
                agent=AgentRef(id=agent.id, slug=agent.slug, name=agent.name),
                model=model_ref,
                multiagentic_modality=multiagentic_modality,
                prev_messages=prev_messages,
                max_iterations=max_iterations,
            ).model_dump()

            session = AgentSession.objects.create(
                conversation=conversation,
                user_message=user_message,
                task_type="chat_message",
                inputs=inputs_data,
                outputs={},
                agent_index=index,
            )
            agent_sessions_created.append(session)
            start_time = time.perf_counter()

            def on_event(event_type: str, data: dict) -> None:
                payload = {
                    "type": event_type,
                    "conversation_id": conversation_id,
                    "agent_slug": agent.slug,
                    "agent_name": agent.name,
                    **data,
                }
                notify_user(user_id, "agent_events_channel", payload)

            # Resolve tools per-agent so tools can use agent_slug closures (e.g. rag_query)
            tools = (
                resolve_tools(
                    tool_names,
                    conversation_id=conversation_id,
                    user_id=user_id,
                    agent_slug=agent.slug,
                )
                if tool_names
                else []
            )

            loop = AgentLoop(
                tools=tools,
                instructions=instructions,
                model=model_slug,
                max_iterations=max_iterations,
                on_event=on_event,
            )

            openai_inputs = _build_agent_loop_inputs(
                prev_messages=prev_messages,
                current_user_text=user_message_text,
                current_user_attachments=message_attachments,
                agent_slug=agent.slug,
                multiagentic_modality=multiagentic_modality,
            )
            result = loop.run(openai_inputs)

            # ---- Update AgentSession (outputs) ----
            from django.utils import timezone

            if isinstance(result.output, str):
                output_value = OutputValue(type="string", value=result.output)
            elif hasattr(result.output, "model_dump"):
                dump = result.output.model_dump(mode="json")
                output_value = OutputValue(type="json", value=dump)
            else:
                output_value = OutputValue(type="string", value=str(result.output))

            outputs_data = AgentSessionOutputs(
                messages=result.messages,
                output=output_value,
                usage=result.usage,
                status="completed",
                error=None,
            ).model_dump()

            session.outputs = outputs_data
            session.iterations = result.iterations
            session.tool_calls_count = len(result.tool_calls)
            session.ended_at = timezone.now()
            session.total_duration = time.perf_counter() - start_time
            session.save()

            # ---- Extract output text for version ----
            import json as _json
            if isinstance(result.output, str):
                output_text = result.output
            elif hasattr(result.output, "model_dump"):
                output_text = _json.dumps(result.output.model_dump(), default=str)
            else:
                output_text = str(result.output)

            version = {
                "agent_slug": agent.slug,
                "agent_name": agent.name,
                "type": "assistant",
                "usage": {
                    "prompt_tokens": result.usage.get("prompt_tokens", 0),
                    "completion_tokens": result.usage.get("completion_tokens", 0),
                    "total_tokens": result.usage.get("total_tokens", 0),
                    "model_slug": model_slug,
                },
            }
            version["text"] = output_text
            versions.append(version)

            total_iterations += result.iterations
            total_tool_calls += len(result.tool_calls)

            # Emit version immediately so frontend can display it in real time
            emit_event("agent_version_ready", {"version": version})

            emit_event("agent_complete", {
                "agent_slug": agent.slug,
                "agent_name": agent.name,
                "index": index + 1,
                "total": len(agents_ordered),
            })

        # ---- Save assistant message with all versions ----
        assistant_message_id = None
        primary_text = versions[0]["text"] if versions else ""
        try:
            conversation = Conversation.objects.get(id=conversation_id)
            assistant_msg = Message.objects.create(
                conversation=conversation,
                type="assistant",
                text=primary_text,
                versions=versions,
            )
            assistant_message_id = assistant_msg.id
            for s in agent_sessions_created:
                s.assistant_message = assistant_msg
                s.save(update_fields=["assistant_message"])
            conversation.generate_title()
        except Conversation.DoesNotExist:
            logger.warning(
                "Conversation %s not found when saving assistant message",
                conversation_id,
            )

        emit_finished({
            "output": primary_text,
            "message_id": assistant_message_id,
            "versions": versions,
            "iterations": total_iterations,
            "tool_calls_count": total_tool_calls,
        })

        logger.info(
            "conversation_agent_task completed: conversation=%s agents=%d iterations=%d tool_calls=%d",
            conversation_id, len(versions), total_iterations, total_tool_calls,
        )

        return {
            "status": "completed",
            "output": primary_text,
            "iterations": total_iterations,
            "tool_calls_count": total_tool_calls,
            "message_id": assistant_message_id,
        }

    except Exception as e:
        logger.error(
            "conversation_agent_task failed: conversation=%s error=%s",
            conversation_id, str(e),
        )
        emit_event("error", {"error": str(e)})

        # Update last created session with error outputs if any
        if agent_sessions_created:
            from django.utils import timezone

            last_session = agent_sessions_created[-1]
            outputs_data = AgentSessionOutputs(
                messages=last_session.outputs.get("messages", []),
                output=OutputValue(type="string", value=""),
                usage=last_session.outputs.get("usage", {}),
                status="error",
                error=OutputError(message=str(e), traceback=tb.format_exc()),
            ).model_dump()
            last_session.outputs = outputs_data
            last_session.ended_at = timezone.now()
            last_session.tool_calls_count = sum(
                1 for m in last_session.outputs.get("messages", [])
                if m.get("type") == "function_call"
            )
            if last_session.started_at:
                last_session.total_duration = (
                    timezone.now() - last_session.started_at
                ).total_seconds()
            last_session.save(
                update_fields=["outputs", "ended_at", "total_duration", "tool_calls_count"]
            )

        return {"status": "error", "error": str(e)}
